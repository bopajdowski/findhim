<!DOCTYPE html>
<html>
<head>
  <title>Wizualizacja BTS - {{ uuid }}</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
      * {
          box-sizing: border-box;
      }

      body {
          margin: 0;
          font-family: Arial, sans-serif;
      }

      .topbar {
          padding: 12px 16px;
          border-bottom: 1px solid #e5e5e5;
          background: #fff;
      }

      .small {
          color: #666;
          font-size: 13px;
          line-height: 1.4;
      }

      .timebox {
          padding: 10px 16px;
          border-bottom: 1px solid #e5e5e5;
          background: #fafafa;
          display: grid;
          gap: 8px;
      }

      .row {
          display: flex;
          gap: 16px;
          align-items: center;
          flex-wrap: wrap;
      }

      .btn {
          padding: 6px 10px;
          border: 1px solid #ccc;
          background: #fff;
          cursor: pointer;
          border-radius: 4px;
          font-size: 12px;
      }

      .btn:disabled {
          opacity: .5;
          cursor: default;
      }

      .dt {
          font-family: monospace;
          padding: 4px 6px;
          border: 1px solid #cfd6dd;
          border-radius: 4px;
          background: #fff;
          font-size: 12px;
      }

      .timeline {
          position: relative;
          height: 32px;
          width: min(980px, 75vw);
          min-width: 320px;
          user-select: none;
      }

      .timeline .track {
          position: absolute;
          left: 0;
          right: 0;
          top: 50%;
          height: 6px;
          transform: translateY(-50%);
          background: #d8dde3;
          border-radius: 999px;
      }

      .timeline .selection {
          position: absolute;
          top: 50%;
          height: 8px;
          transform: translateY(-50%);
          background: #1f6feb;
          border-radius: 999px;
          opacity: 0.9;
          cursor: grab;
      }

      .timeline .selection:active {
          cursor: grabbing;
      }

      .timeline .handle {
          position: absolute;
          top: 50%;
          width: 14px;
          height: 22px;
          transform: translate(-50%, -50%);
          background: #0b3d91;
          border-radius: 4px;
          cursor: ew-resize;
          box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.85);
      }

      .hiddenRange {
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          opacity: 0;
          pointer-events: none;
      }

      #map {
          height: calc(100vh - 190px);
          width: 100%;
      }

      .legend {
          background: #fff;
          border: 1px solid rgba(0, 0, 0, 0.2);
          border-radius: 6px;
          padding: 10px 12px;
          font-size: 12px;
          line-height: 1.4;
      }

      .dot {
          display: inline-block;
          width: 10px;
          height: 10px;
          border-radius: 50%;
          margin-right: 6px;
          background: #ff0000;
      }

      .line {
          display: inline-block;
          width: 22px;
          height: 0;
          border-top: 2px dashed #b30000;
          margin: 0 6px 3px 0;
      }

      .ring {
          display: inline-block;
          width: 10px;
          height: 10px;
          border-radius: 50%;
          border: 2px solid #0066ff;
          margin-right: 6px;
      }
  </style>
</head>

<body>
<div class="topbar">
  <div><strong>UUID:</strong> <span style="font-family: monospace;">{{ uuid }}</span></div>
  <div class="small">
    Oś czasu filtruje zdarzenia (rekordy), a z nich wynikają BTS-y rysowane na mapie.
  </div>
</div>

<div class="timebox">
  <div class="row">
    <div>
      <strong>Wybrany od:</strong>
      <input id="dtFrom" class="dt" type="datetime-local" step="60">
    </div>
    <div>
      <strong>do:</strong>
      <input id="dtTo" class="dt" type="datetime-local" step="60">
    </div>
    <div class="small" id="outCount"></div>
  </div>

  <div class="row" style="gap:8px;">
    <button class="btn" id="btnLeft" title="Przesuń okno w lewo">⟵</button>

    <div id="timeline" class="timeline">
      <div class="track"></div>
      <div id="selection" class="selection"></div>
      <div id="handleL" class="handle handle-l" title="Start"></div>
      <div id="handleR" class="handle handle-r" title="Koniec"></div>
      <input id="rangeFrom" type="range" class="hiddenRange">
      <input id="rangeTo" type="range" class="hiddenRange">
    </div>

    <button class="btn" id="btnRight" title="Przesuń okno w prawo">⟶</button>

    <button class="btn" id="btnPlay" title="Odtwarzaj przesuwanie okna">Play</button>

    <label class="small">Przesuwaj co (min):</label>
    <input id="shiftMin" type="number" min="1" step="1" value="10" style="width:70px;">

    <button class="btn" id="btnReset">Reset (1h)</button>
  </div>

  <div class="small">
    Domyślny interwał: 1 godzina. Przeciągnij uchwyty lub środek (niebieski pasek), aby przesuwać okno.
    Play przesuwa okno automatycznie o ten sam krok co strzałki.
  </div>
</div>

<div id="map"></div>

<script>
    // Dane z Django: zakres czasu importu + lista zdarzeń (eventów) z BTS i parametrami sektora.
    // events: [{start_ms,end_ms,coords,azymut,kt,zasieg,typ,bts}, ...]
    const MIN_TS = {{ min_ts|default:"null" }};
    const MAX_TS = {{ max_ts|default:"null" }};
    const events = {{ events_json|safe }};

    // Leaflet
    const map = L.map('map').setView([52.0, 19.0], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const layer = L.layerGroup().addTo(map);

    // UI
    const rangeFrom = document.getElementById('rangeFrom');
    const rangeTo = document.getElementById('rangeTo');

    const dtFrom = document.getElementById('dtFrom');
    const dtTo = document.getElementById('dtTo');

    const outCount = document.getElementById('outCount');

    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnReset = document.getElementById('btnReset');
    const btnPlay = document.getElementById('btnPlay');
    const shiftMin = document.getElementById('shiftMin');

    const timeline = document.getElementById('timeline');
    const selection = document.getElementById('selection');
    const handleL = document.getElementById('handleL');
    const handleR = document.getElementById('handleR');

    const STEP = 60 * 1000; // 1 minuta
    const DEFAULT_WINDOW = 60 * 60 * 1000; // 1 godzina

    // Play/Pause
    let isPlaying = false;
    let playTimer = null;
    const playIntervalMs = 200; // tempo odświeżania (nie "czas przesunięcia osi")

    function clamp(v, a, b) {
        return Math.max(a, Math.min(v, b));
    }

    function normalize() {
        let f = Number(rangeFrom.value);
        let t = Number(rangeTo.value);
        if (f > t) {
            const tmp = f;
            f = t;
            t = tmp;
        }
        f = clamp(f, MIN_TS, MAX_TS);
        t = clamp(t, MIN_TS, MAX_TS);
        rangeFrom.value = f;
        rangeTo.value = t;
        return {f, t};
    }

    function xToTs(x) {
        const rect = timeline.getBoundingClientRect();
        const p = clamp((x - rect.left) / rect.width, 0, 1);
        const ts = MIN_TS + p * (MAX_TS - MIN_TS);
        return Math.round(ts / STEP) * STEP;
    }

    function pad2(n) {
        return String(n).padStart(2, '0');
    }

    // datetime-local: YYYY-MM-DDTHH:MM (bez sekund)
    function tsToLocalInput(ts) {
        const d = new Date(Number(ts));
        const y = d.getFullYear();
        const m = pad2(d.getMonth() + 1);
        const day = pad2(d.getDate());
        const h = pad2(d.getHours());
        const min = pad2(d.getMinutes());
        return `${y}-${m}-${day}T${h}:${min}`;
    }

    function localInputToTs(val) {
        if (!val) return null;
        const d = new Date(val);
        const ts = d.getTime();
        if (!Number.isFinite(ts)) return null;
        return Math.round(ts / STEP) * STEP;
    }

    function renderTimeline() {
        const {f, t} = normalize();

        dtFrom.value = tsToLocalInput(f);
        dtTo.value = tsToLocalInput(t);

        const rect = timeline.getBoundingClientRect();
        const leftP = (f - MIN_TS) / (MAX_TS - MIN_TS);
        const rightP = (t - MIN_TS) / (MAX_TS - MIN_TS);

        const leftPx = leftP * rect.width;
        const rightPx = rightP * rect.width;

        selection.style.left = `${leftPx}px`;
        selection.style.width = `${Math.max(0, rightPx - leftPx)}px`;

        handleL.style.left = `${leftPx}px`;
        handleR.style.left = `${rightPx}px`;
    }

    function eventOverlapsWindow(ev, f, t) {
        // overlap: start <= t AND (end null OR end >= f)
        const s = ev.start_ms;
        const e = ev.end_ms;
        if (s === null || s === undefined) return false;
        if (s > t) return false;
        if (e === null || e === undefined) return true;
        return e >= f;
    }

    function uniqueKey(ev) {
        // deduplikacja BTS (żeby nie rysować identycznych sektorów tysiące razy)
        return `${ev.coords}|${ev.azymut}|${ev.kt}|${ev.zasieg}`;
    }

    function redraw() {
        const {f, t} = normalize();

        const filtered = events.filter(ev => eventOverlapsWindow(ev, f, t));
        const seen = new Set();
        const btsy = [];
        for (const ev of filtered) {
            const k = uniqueKey(ev);
            if (seen.has(k)) continue;
            seen.add(k);
            btsy.push(ev);
        }

        outCount.textContent = `| zdarzeń w oknie: ${filtered.length}, BTS do rysowania: ${btsy.length}`;

        layer.clearLayers();

        const bounds = [];

        btsy.forEach((bts) => {
            const parts = String(bts.coords || '').split(',');
            const lat = Number(parts[0]);
            const lon = Number(parts[1]);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

            const az = Number(bts.azymut);
            const kt = Number(bts.kt);
            const zas = Number(bts.zasieg);
            if (!Number.isFinite(az) || !Number.isFinite(kt) || !Number.isFinite(zas)) return;

            bounds.push([lat, lon]);

            const isOmni = kt >= 360;
            const hasSector = kt > 0 && kt < 360;

            // Punkt BTS
            L.circleMarker([lat, lon], {
                radius: 6,
                color: '#333',
                weight: 1,
                fillColor: '#ff0000',
                fillOpacity: 0.95
            }).addTo(layer).bindPopup(`
          <strong>${bts.bts ? bts.bts : 'BTS'}</strong><br>
          Typ: ${bts.typ ? bts.typ : ''}<br><br>
          Azymut: ${az}°<br>
          Kąt: ${kt}°<br>
          Zasięg: ${zas} m<br>
          Tryb: ${isOmni ? 'dookólna (360°)' : 'sektor'}
        `);

            // Okrąg zasięgu (metry)
            L.circle([lat, lon], {
                radius: zas,
                color: '#0066ff',
                weight: 1,
                opacity: 0.25,
                fillOpacity: 0.0
            }).addTo(layer);

            // Linia azymutu (turf: [lon,lat], km)
            const end = turf.destination([lon, lat], zas / 1000.0, az, {units: 'kilometers'});
            const endLat = end.geometry.coordinates[1];
            const endLon = end.geometry.coordinates[0];

            L.polyline([[lat, lon], [endLat, endLon]], {
                color: '#b30000',
                weight: 2,
                dashArray: '6 10',
                opacity: 0.85
            }).addTo(layer);

            // Sektor jako wycinek koła (arcPoints)
            if (hasSector) {
                const start = az - (kt / 2.0);
                const stop = az + (kt / 2.0);

                const steps = 60;
                const arc = [];
                for (let i = 0; i <= steps; i++) {
                    const bearing = start + ((stop - start) * (i / steps));
                    const p = turf.destination([lon, lat], zas / 1000.0, bearing, {units: 'kilometers'});
                    arc.push([p.geometry.coordinates[1], p.geometry.coordinates[0]]); // [lat,lon]
                }

                const sectorLatLngs = [[lat, lon], ...arc, [lat, lon]];
                L.polygon(sectorLatLngs, {
                    color: '#0066ff',
                    weight: 1,
                    opacity: 0.6,
                    fillColor: '#0066ff',
                    fillOpacity: 0.18
                }).addTo(layer);
            }
        });

        if (bounds.length) {
            map.fitBounds(bounds, {padding: [20, 20], maxZoom: 16});
        }
    }

    function setPlayUI() {
        btnPlay.textContent = isPlaying ? 'Pause' : 'Play';
        btnLeft.disabled = isPlaying;
        btnRight.disabled = isPlaying;
    }

    function stopPlay() {
        isPlaying = false;
        if (playTimer) {
            clearInterval(playTimer);
            playTimer = null;
        }
        setPlayUI();
    }

    function shiftWindow(dir) {
        const stepMin = Math.max(1, Number(shiftMin.value || 10));
        const delta = stepMin * 60 * 1000;

        const {f, t} = normalize();
        const win = t - f;
        if (win <= 0) return;

        let nf = f + dir * delta;
        let nt = t + dir * delta;

        if (nf < MIN_TS) {
            nf = MIN_TS;
            nt = MIN_TS + win;
        }
        if (nt > MAX_TS) {
            nt = MAX_TS;
            nf = MAX_TS - win;
        }

        rangeFrom.value = nf;
        rangeTo.value = nt;

        renderTimeline();
        redraw();
    }

    function stepForward() {
        shiftWindow(1);
        const {t} = normalize();
        if (t >= MAX_TS) stopPlay();
    }

    function startPlay() {
        if (isPlaying) return;
        isPlaying = true;
        setPlayUI();
        playTimer = setInterval(() => {
            try {
                stepForward();
            } catch (e) {
                console.error(e);
                stopPlay();
            }
        }, playIntervalMs);
    }

    function initTimeUI() {
        if (MIN_TS === null || MAX_TS === null || MIN_TS >= MAX_TS) {
            outCount.textContent = 'Brak zakresu czasu w danych (min/max).';
            btnLeft.disabled = true;
            btnRight.disabled = true;
            btnReset.disabled = true;
            btnPlay.disabled = true;
            return;
        }

        rangeFrom.min = MIN_TS;
        rangeFrom.max = MAX_TS;
        rangeFrom.step = STEP;
        rangeTo.min = MIN_TS;
        rangeTo.max = MAX_TS;
        rangeTo.step = STEP;

        const start = MIN_TS;
        const end = clamp(MIN_TS + DEFAULT_WINDOW, MIN_TS + STEP, MAX_TS);

        rangeFrom.value = start;
        rangeTo.value = end;

        renderTimeline();
        redraw();

        window.addEventListener('resize', () => renderTimeline());
        setPlayUI();
    }

    // Drag: L / R / MID
    let dragMode = null; // 'L' | 'R' | 'MID'
    let midOffsetTs = 0;
    let midWin = 0;

    function startDrag(mode, ev) {
        stopPlay(); // manual = stop autoplay
        dragMode = mode;
        ev.preventDefault();

        const {f, t} = normalize();
        if (mode === 'MID') {
            midOffsetTs = xToTs(ev.clientX) - f;
            midWin = t - f;
        }

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function onDrag(ev) {
        if (!dragMode) return;
        const ts = xToTs(ev.clientX);

        if (dragMode === 'L') {
            rangeFrom.value = clamp(ts, MIN_TS, Number(rangeTo.value));
        } else if (dragMode === 'R') {
            rangeTo.value = clamp(ts, Number(rangeFrom.value), MAX_TS);
        } else if (dragMode === 'MID') {
            let nf = ts - midOffsetTs;
            nf = clamp(nf, MIN_TS, MAX_TS - midWin);
            const nt = nf + midWin;
            rangeFrom.value = nf;
            rangeTo.value = nt;
        }

        renderTimeline();
        redraw();
    }

    function stopDrag() {
        dragMode = null;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
    }

    handleL.addEventListener('mousedown', (ev) => startDrag('L', ev));
    handleR.addEventListener('mousedown', (ev) => startDrag('R', ev));
    selection.addEventListener('mousedown', (ev) => startDrag('MID', ev));

    // Manual time inputs
    dtFrom.addEventListener('change', () => {
        stopPlay();
        const ts = localInputToTs(dtFrom.value);
        if (ts === null) return;
        rangeFrom.value = clamp(ts, MIN_TS, Number(rangeTo.value));
        renderTimeline();
        redraw();
    });

    dtTo.addEventListener('change', () => {
        stopPlay();
        const ts = localInputToTs(dtTo.value);
        if (ts === null) return;
        rangeTo.value = clamp(ts, Number(rangeFrom.value), MAX_TS);
        renderTimeline();
        redraw();
    });

    // Buttons
    btnLeft.addEventListener('click', () => {
        stopPlay();
        shiftWindow(-1);
    });
    btnRight.addEventListener('click', () => {
        stopPlay();
        shiftWindow(1);
    });
    btnReset.addEventListener('click', () => {
        stopPlay();
        rangeFrom.value = MIN_TS;
        rangeTo.value = clamp(MIN_TS + DEFAULT_WINDOW, MIN_TS + STEP, MAX_TS);
        renderTimeline();
        redraw();
    });

    btnPlay.addEventListener('click', () => {
        if (isPlaying) stopPlay();
        else startPlay();
    });

    // Legenda
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = `
        <div><span class="dot"></span> BTS w aktualnym oknie czasu</div>
        <div style="margin-top:6px;"><span class="line"></span> Linia azymutu</div>
        <div><span class="ring"></span> Zasięg (okrąg; metry)</div>
        <div>Wycinek: sektor (0&lt;kt&lt;360; oś=azymut)</div>
        <div>kt=360: dookólna (sam okrąg)</div>
      `;
        return div;
    };
    legend.addTo(map);

    initTimeUI();
</script>
</body>
</html>
